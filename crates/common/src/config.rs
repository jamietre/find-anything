use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::OnceLock;
use tracing::warn;

// ── Built-in defaults (embedded from TOML at compile time) ───────────────────

/// Private structs used only for parsing the embedded defaults files.
/// They have NO serde(default) attributes to prevent circular calls back into
/// the default_* functions while the OnceLock is being initialised.
#[derive(Deserialize)]
struct ClientDefaults {
    scan: ScanDefaults,
    watch: WatchDefaults,
    log: LogDefaults,
}

#[derive(Deserialize)]
struct ScanDefaults {
    exclude: Vec<String>,
    max_file_size_mb: u64,
    max_line_length: usize,
    noindex_file: String,
    index_file: String,
    archives: ArchiveDefaults,
}

#[derive(Deserialize)]
struct ArchiveDefaults {
    max_depth: usize,
    max_temp_file_mb: usize,
    max_7z_solid_block_mb: usize,
}

#[derive(Deserialize)]
struct WatchDefaults {
    debounce_ms: u64,
}

#[derive(Deserialize)]
struct LogDefaults {
    ignore: Vec<String>,
}

#[derive(Deserialize)]
struct ServerDefaults {
    server: ServerSettingsDefaults,
    search: SearchDefaults,
    // log.ignore shares the same default_log_ignore() function as the client;
    // both files have identical values.  Parsed by serde but not stored here.
}

#[derive(Deserialize)]
struct ServerSettingsDefaults {
    bind: String,
}

#[derive(Deserialize)]
struct SearchDefaults {
    default_limit: usize,
    max_limit: usize,
    fts_candidate_limit: usize,
    context_window: usize,
}

static CLIENT_DEFAULTS: OnceLock<ClientDefaults> = OnceLock::new();
static SERVER_DEFAULTS: OnceLock<ServerDefaults> = OnceLock::new();

fn client_defaults() -> &'static ClientDefaults {
    CLIENT_DEFAULTS.get_or_init(|| {
        toml::from_str(include_str!("defaults_client.toml"))
            .expect("built-in defaults_client.toml is invalid — this is a compile-time bug")
    })
}

fn server_defaults() -> &'static ServerDefaults {
    SERVER_DEFAULTS.get_or_init(|| {
        toml::from_str(include_str!("defaults_server.toml"))
            .expect("built-in defaults_server.toml is invalid — this is a compile-time bug")
    })
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientConfig {
    pub server: ServerConfig,
    #[serde(default)]
    pub sources: Vec<SourceConfig>,
    #[serde(default)]
    pub scan: ScanConfig,
    #[serde(default)]
    pub watch: WatchConfig,
    #[serde(default)]
    pub log: LogConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub url: String,
    pub token: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceConfig {
    pub name: String,
    pub paths: Vec<String>,
    #[serde(default)]
    pub base_url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanConfig {
    #[serde(default = "default_excludes")]
    pub exclude: Vec<String>,

    /// Additional exclude patterns appended to `exclude` after parsing.
    ///
    /// Use this to extend the built-in defaults without replacing them.
    /// `exclude` alone **replaces** the defaults; `exclude_extra` always
    /// **adds to** whatever `exclude` contains.
    ///
    /// Example in client.toml:
    /// ```toml
    /// [scan]
    /// exclude_extra = ["**/my-build/**", "*.tmp"]
    /// ```
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub exclude_extra: Vec<String>,

    #[serde(default = "default_max_file_size_mb")]
    pub max_file_size_mb: u64,

    #[serde(default)]
    pub follow_symlinks: bool,

    #[serde(default)]
    pub include_hidden: bool,

    #[serde(default)]
    pub archives: ArchiveConfig,

    /// Maximum line length (in characters) for PDF text extraction.
    /// Lines longer than this are split at word boundaries so that context
    /// retrieval returns meaningful snippets.
    /// Set to 0 to disable wrapping. Default: 120.
    #[serde(default = "default_max_line_length")]
    pub max_line_length: usize,

    /// Name of the marker file that signals a directory (and all descendants)
    /// should be excluded from indexing. Default: ".noindex".
    #[serde(default = "default_noindex_file")]
    pub noindex_file: String,

    /// Name of the per-directory config file that overrides scan settings for
    /// a subtree. Default: ".index".
    #[serde(default = "default_index_file")]
    pub index_file: String,

    /// Directory containing find-extract-* binaries.
    /// None = auto-detect (same dir as the executable, then PATH).
    #[serde(default)]
    pub extractor_dir: Option<String>,
}

impl Default for ScanConfig {
    fn default() -> Self {
        Self {
            exclude: default_excludes(),
            exclude_extra: vec![],
            max_file_size_mb: default_max_file_size_mb(),
            follow_symlinks: false,
            include_hidden: false,
            archives: ArchiveConfig::default(),
            max_line_length: default_max_line_length(),
            noindex_file: default_noindex_file(),
            index_file: default_index_file(),
            extractor_dir: None,
        }
    }
}

impl ScanConfig {
    /// Produce a new `ScanConfig` by applying a per-directory override.
    ///
    /// - `exclude` is **additive**: patterns are appended to the parent list.
    /// - All other fields are **replacement**: the innermost value wins.
    /// - `noindex_file` and `index_file` are never overridden (global-only).
    pub fn apply_override(&self, ov: &ScanOverride) -> ScanConfig {
        let mut result = self.clone();
        if let Some(extra) = &ov.exclude {
            result.exclude.extend(extra.iter().cloned());
        }
        if let Some(v) = ov.max_file_size_mb {
            result.max_file_size_mb = v;
        }
        if let Some(v) = ov.include_hidden {
            result.include_hidden = v;
        }
        if let Some(v) = ov.follow_symlinks {
            result.follow_symlinks = v;
        }
        if let Some(v) = ov.max_line_length {
            result.max_line_length = v;
        }
        if let Some(arch_ov) = &ov.archives {
            if let Some(v) = arch_ov.enabled {
                result.archives.enabled = v;
            }
            if let Some(v) = arch_ov.max_depth {
                result.archives.max_depth = v;
            }
        }
        result
    }
}

/// Partial scan config read from a per-directory `.index` file.
/// All fields are optional; `None` means "inherit from parent config".
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ScanOverride {
    /// Additional exclude patterns (appended to parent list, never removed).
    pub exclude: Option<Vec<String>>,
    pub max_file_size_mb: Option<u64>,
    pub include_hidden: Option<bool>,
    pub follow_symlinks: Option<bool>,
    pub archives: Option<ArchiveOverride>,
    pub max_line_length: Option<usize>,
}

/// Archive-specific fields for a `ScanOverride`.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ArchiveOverride {
    pub enabled: Option<bool>,
    pub max_depth: Option<usize>,
}

/// Load and parse a `.index` override file from `dir`.
/// Returns `None` if the file is absent, unreadable, or unparseable.
pub fn load_dir_override(dir: &Path, index_filename: &str) -> Option<ScanOverride> {
    let path = dir.join(index_filename);
    let content = std::fs::read_to_string(&path).ok()?;
    match toml::from_str::<ScanOverride>(&content) {
        Ok(ov) => Some(ov),
        Err(e) => {
            warn!("invalid {} file at {}: {e}", index_filename, path.display());
            None
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchiveConfig {
    #[serde(default = "default_true")]
    pub enabled: bool,
    /// Maximum nesting depth for archives-within-archives.
    /// Prevents infinite recursion from malicious zip bombs.
    /// Default: 10. Set to 1 to only extract direct members (no nested archives).
    #[serde(default = "default_max_archive_depth")]
    pub max_depth: usize,
    /// Maximum size in MB of a temporary file created when extracting a nested
    /// 7z or large nested zip archive.  Guards against excessive disk use from
    /// deeply compressed or unusually large inner archives.  Default: 500 MB.
    #[serde(default = "default_max_archive_temp_file_mb")]
    pub max_temp_file_mb: usize,
    /// Maximum total uncompressed size in MB of a single 7z solid block.
    ///
    /// When decompressing a 7z solid block, the LZMA decoder allocates a
    /// dictionary buffer proportional to the block's total unpack size,
    /// regardless of how large any individual file within the block is.
    /// Blocks whose total unpack size exceeds this limit are skipped: all
    /// member files are indexed by filename only (no content extraction).
    ///
    /// Lower this on memory-constrained systems (NAS boxes, containers).
    /// Default: 256 MB.
    #[serde(default = "default_max_7z_solid_block_mb")]
    pub max_7z_solid_block_mb: usize,
}

impl Default for ArchiveConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_depth: default_max_archive_depth(),
            max_temp_file_mb: default_max_archive_temp_file_mb(),
            max_7z_solid_block_mb: default_max_7z_solid_block_mb(),
        }
    }
}

fn default_max_archive_depth() -> usize       { client_defaults().scan.archives.max_depth }
fn default_max_archive_temp_file_mb() -> usize { client_defaults().scan.archives.max_temp_file_mb }
fn default_max_7z_solid_block_mb() -> usize   { client_defaults().scan.archives.max_7z_solid_block_mb }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WatchConfig {
    /// Milliseconds to wait after last event before processing the batch.
    #[serde(default = "default_debounce_ms")]
    pub debounce_ms: u64,

    /// Directory containing find-extract-* binaries.
    /// None = auto-detect (same dir as find-watch, then PATH).
    #[serde(default)]
    pub extractor_dir: Option<String>,
}

impl Default for WatchConfig {
    fn default() -> Self {
        Self {
            debounce_ms: default_debounce_ms(),
            extractor_dir: None,
        }
    }
}

fn default_debounce_ms() -> u64      { client_defaults().watch.debounce_ms }
fn default_excludes() -> Vec<String> { client_defaults().scan.exclude.clone() }
fn default_max_file_size_mb() -> u64 { client_defaults().scan.max_file_size_mb }
fn default_max_line_length() -> usize { client_defaults().scan.max_line_length }
fn default_noindex_file() -> String  { client_defaults().scan.noindex_file.clone() }
fn default_index_file() -> String    { client_defaults().scan.index_file.clone() }
fn default_true() -> bool            { true }

/// Configuration passed to extractor functions.
///
/// Bundles all per-extraction settings into one struct so that adding new
/// options in the future only requires updating this struct and its
/// construction site — not every function signature in the call chain.
///
/// Construction sites that don't care about a particular field can use
/// `..ExtractorConfig::default()` to forward-compatibly inherit the defaults.
#[derive(Debug, Clone, Copy)]
pub struct ExtractorConfig {
    /// Maximum file/member size in KB; content extraction is skipped above this.
    pub max_size_kb: usize,
    /// Maximum archive nesting depth; prevents zip-bomb recursion.
    pub max_depth: usize,
    /// Maximum line length in characters for PDF extraction.
    /// Long lines are wrapped at word boundaries. 0 = no wrapping.
    pub max_line_length: usize,
    /// Maximum size in MB of a temporary file used when extracting nested 7z
    /// archives (which require a seekable file path) or oversized nested zips.
    /// Guards against excessive disk use. Default: 500 MB.
    pub max_temp_file_mb: usize,
    /// When false (default), archive members whose path contains a dot-prefixed
    /// component (e.g. `.terraform/`, `.git/`) are skipped entirely, consistent
    /// with the filesystem walk's `include_hidden = false` behaviour.
    pub include_hidden: bool,
    /// Maximum total uncompressed size in MB of a 7z solid block before
    /// falling back to filename-only extraction.  Maps to
    /// `scan.archives.max_7z_solid_block_mb`.  Default: 256 MB.
    pub max_7z_solid_block_mb: usize,
}

impl Default for ExtractorConfig {
    fn default() -> Self {
        Self {
            max_size_kb: 10 * 1024,
            max_depth: default_max_archive_depth(),
            max_line_length: default_max_line_length(),
            max_temp_file_mb: default_max_archive_temp_file_mb(),
            include_hidden: false,
            max_7z_solid_block_mb: default_max_7z_solid_block_mb(),
        }
    }
}

impl ExtractorConfig {
    /// Build an `ExtractorConfig` from the scan section of the client config.
    pub fn from_scan(scan: &ScanConfig) -> Self {
        Self {
            max_size_kb: scan.max_file_size_mb as usize * 1024,
            max_depth: scan.archives.max_depth,
            max_line_length: scan.max_line_length,
            max_temp_file_mb: scan.archives.max_temp_file_mb,
            include_hidden: scan.include_hidden,
            max_7z_solid_block_mb: scan.archives.max_7z_solid_block_mb,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerAppConfig {
    pub server: ServerAppSettings,
    #[serde(default)]
    pub search: SearchSettings,
    #[serde(default)]
    pub log: LogConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerAppSettings {
    #[serde(default = "default_bind")]
    pub bind: String,
    pub data_dir: String,
    pub token: String,
}

fn default_bind() -> String { server_defaults().server.bind.clone() }

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchSettings {
    #[serde(default = "default_search_limit")]
    pub default_limit: usize,
    #[serde(default = "default_max_limit")]
    pub max_limit: usize,
    #[serde(default = "default_fts_candidate_limit")]
    pub fts_candidate_limit: usize,
    /// Number of lines shown before and after each match in search result cards.
    /// Total lines displayed = 2 × context_window + 1. Default: 1 (3 lines total).
    #[serde(default = "default_context_window")]
    pub context_window: usize,
}

impl Default for SearchSettings {
    fn default() -> Self {
        Self {
            default_limit: default_search_limit(),
            max_limit: default_max_limit(),
            fts_candidate_limit: default_fts_candidate_limit(),
            context_window: default_context_window(),
        }
    }
}

fn default_search_limit() -> usize    { server_defaults().search.default_limit }
fn default_max_limit() -> usize       { server_defaults().search.max_limit }
fn default_fts_candidate_limit() -> usize { server_defaults().search.fts_candidate_limit }
fn default_context_window() -> usize  { server_defaults().search.context_window }

// ── Log config ────────────────────────────────────────────────────────────────

/// Logging configuration shared by client and server.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct LogConfig {
    /// Regular-expression patterns for log messages to suppress.
    /// Any event whose message contains a match for one of these patterns is
    /// silently dropped before it reaches the output formatter.
    /// Default: suppresses "unknown glyph name" noise from pdf-extract.
    #[serde(default = "default_log_ignore")]
    pub ignore: Vec<String>,
}

fn default_log_ignore() -> Vec<String> { client_defaults().log.ignore.clone() }

/// Resolves the server config path using the following priority:
///
/// 1. `FIND_ANYTHING_SERVER_CONFIG` environment variable (if set)
/// 2. `$XDG_CONFIG_HOME/find-anything/server.toml` (if `XDG_CONFIG_HOME` is set)
/// 3. `/etc/find-anything/server.toml` if running as root (uid 0) — typical for system services
/// 4. `~/.config/find-anything/server.toml` otherwise
pub fn default_server_config_path() -> String {
    if let Ok(p) = std::env::var("FIND_ANYTHING_SERVER_CONFIG") {
        return p;
    }
    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
        return format!("{xdg}/find-anything/server.toml");
    }
    // Running as root → system-wide config location used by service units.
    #[cfg(unix)]
    if unsafe { libc::getuid() } == 0 {
        return "/etc/find-anything/server.toml".into();
    }
    let home = std::env::var("HOME").unwrap_or_default();
    format!("{home}/.config/find-anything/server.toml")
}

/// Resolves the client config path using the following priority:
///
/// 1. `FIND_ANYTHING_CONFIG` environment variable (if set)
/// 2. `$XDG_CONFIG_HOME/find-anything/client.toml` (if `XDG_CONFIG_HOME` is set)
/// 3. `/etc/find-anything/client.toml` (when running as root, e.g. system service)
/// 4. `~/.config/find-anything/client.toml` (default)
pub fn default_config_path() -> String {
    if let Ok(p) = std::env::var("FIND_ANYTHING_CONFIG") {
        return p;
    }
    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
        return format!("{xdg}/find-anything/client.toml");
    }
    // Running as root → system-wide config location used by service units.
    #[cfg(unix)]
    if unsafe { libc::getuid() } == 0 {
        return "/etc/find-anything/client.toml".into();
    }
    let home = std::env::var("HOME").unwrap_or_default();
    format!("{home}/.config/find-anything/client.toml")
}

// ── Config loaders with unknown-field warnings ─────────────────────────────

/// Parse a client `client.toml` string, emitting `warn!` for any unrecognised keys.
pub fn parse_client_config(toml_str: &str) -> Result<ClientConfig> {
    let value: toml::Value = toml::from_str(toml_str).context("invalid TOML")?;
    let mut unknown = Vec::new();
    let mut cfg: ClientConfig = serde_ignored::deserialize(value, |path| {
        unknown.push(path.to_string());
    })
    .context("parsing client config")?;
    for key in &unknown {
        warn!("unknown config key: {key}");
    }
    // Merge exclude_extra into exclude so the rest of the codebase only
    // needs to look at one field.
    cfg.scan.exclude.extend(std::mem::take(&mut cfg.scan.exclude_extra));
    Ok(cfg)
}

/// Parse a server `server.toml` string, emitting `warn!` for any unrecognised keys.
pub fn parse_server_config(toml_str: &str) -> Result<ServerAppConfig> {
    let value: toml::Value = toml::from_str(toml_str).context("invalid TOML")?;
    let mut unknown = Vec::new();
    let cfg = serde_ignored::deserialize(value, |path| {
        unknown.push(path.to_string());
    })
    .context("parsing server config")?;
    for key in &unknown {
        warn!("unknown config key: {key}");
    }
    Ok(cfg)
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Verify that both embedded defaults files parse without error.
    /// Catches TOML syntax mistakes and missing required fields at test time.
    #[test]
    fn embedded_defaults_parse() {
        let _c = client_defaults();
        let _s = server_defaults();
    }

    #[test]
    fn watch_config_default_values() {
        let w = WatchConfig::default();
        assert_eq!(w.debounce_ms, 500);
        assert!(w.extractor_dir.is_none());
    }

    #[test]
    fn watch_config_serde_missing_fields_use_defaults() {
        // A config with no [watch] section should deserialise to defaults.
        let w: WatchConfig = serde_json::from_str("{}").unwrap();
        assert_eq!(w.debounce_ms, 500);
        assert!(w.extractor_dir.is_none());
    }

    #[test]
    fn watch_config_serde_explicit_values() {
        let w: WatchConfig =
            serde_json::from_str(r#"{"debounce_ms":200,"extractor_dir":"/usr/local/bin"}"#)
                .unwrap();
        assert_eq!(w.debounce_ms, 200);
        assert_eq!(w.extractor_dir.as_deref(), Some("/usr/local/bin"));
    }

    #[test]
    fn scan_config_default_control_file_names() {
        let s = ScanConfig::default();
        assert_eq!(s.noindex_file, ".noindex");
        assert_eq!(s.index_file, ".index");
    }

    #[test]
    fn scan_override_exclude_is_additive() {
        let base = ScanConfig {
            exclude: vec!["**/.git/**".into()],
            ..ScanConfig::default()
        };
        let ov = ScanOverride {
            exclude: Some(vec!["*.log".into()]),
            ..ScanOverride::default()
        };
        let result = base.apply_override(&ov);
        assert_eq!(result.exclude, vec!["**/.git/**", "*.log"]);
    }

    #[test]
    fn scan_override_replaces_scalar_fields() {
        let base = ScanConfig::default();
        let ov = ScanOverride {
            include_hidden: Some(true),
            max_file_size_mb: Some(99),
            ..ScanOverride::default()
        };
        let result = base.apply_override(&ov);
        assert!(result.include_hidden);
        assert_eq!(result.max_file_size_mb, 99);
        // noindex_file/index_file are inherited unchanged
        assert_eq!(result.noindex_file, ".noindex");
    }

    #[test]
    fn scan_override_archive_fields() {
        let base = ScanConfig::default();
        let ov = ScanOverride {
            archives: Some(ArchiveOverride { enabled: Some(false), max_depth: Some(2) }),
            ..ScanOverride::default()
        };
        let result = base.apply_override(&ov);
        assert!(!result.archives.enabled);
        assert_eq!(result.archives.max_depth, 2);
        assert_eq!(result.archives.max_temp_file_mb, 500); // unchanged
    }

    #[test]
    fn scan_override_toml_parses() {
        let toml = r#"
include_hidden = true
exclude = ["*.tmp"]

[archives]
enabled = false
"#;
        let ov: ScanOverride = toml::from_str(toml).unwrap();
        assert_eq!(ov.include_hidden, Some(true));
        assert_eq!(ov.exclude, Some(vec!["*.tmp".into()]));
        assert_eq!(ov.archives.as_ref().unwrap().enabled, Some(false));
    }

    #[test]
    fn exclude_extra_appends_to_defaults() {
        let toml = r#"
[server]
url = "http://localhost:8080"
token = "t"

[scan]
exclude_extra = ["**/my-build/**", "*.tmp"]
"#;
        let cfg = parse_client_config(toml).unwrap();
        // exclude_extra is merged into exclude; the built-in defaults come first
        let defaults = default_excludes();
        assert!(cfg.scan.exclude.starts_with(&defaults));
        assert!(cfg.scan.exclude.contains(&"**/my-build/**".to_string()));
        assert!(cfg.scan.exclude.contains(&"*.tmp".to_string()));
        // exclude_extra itself is empty after merging
        assert!(cfg.scan.exclude_extra.is_empty());
    }

    #[test]
    fn exclude_replaces_defaults() {
        let toml = r#"
[server]
url = "http://localhost:8080"
token = "t"

[scan]
exclude = ["*.only"]
"#;
        let cfg = parse_client_config(toml).unwrap();
        assert_eq!(cfg.scan.exclude, vec!["*.only"]);
    }

    #[test]
    fn client_config_watch_field_defaults_when_absent() {
        // Simulate a client.toml that has no [watch] section.
        let json = r#"{
            "server": {"url": "http://localhost:8080", "token": "t"},
            "sources": []
        }"#;
        let cfg: ClientConfig = serde_json::from_str(json).unwrap();
        assert_eq!(cfg.watch.debounce_ms, 500);
        assert!(cfg.watch.extractor_dir.is_none());
    }
}
